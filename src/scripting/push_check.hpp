/*
   Copyright (C) 2017 by the Battle for Wesnoth Project http://www.wesnoth.org/

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY.

   See the COPYING file for more details.
*/

#pragma once

#include "scripting/lua_common.hpp"

#include <type_traits>
#include <boost/mpl/not.hpp>
#include <boost/mpl/and.hpp>
#include <boost/mpl/has_xxx.hpp>
#include "tstring.hpp"
#include "map/location.hpp"
#include "lua/lauxlib.h"
#include "lua/lua.h"

#include <cassert>

class enum_tag;

namespace lua_check_impl
{
	namespace detail
	{
		BOOST_MPL_HAS_XXX_TRAIT_DEF(value_type)
		BOOST_MPL_HAS_XXX_TRAIT_DEF(iterator)
		BOOST_MPL_HAS_XXX_TRAIT_DEF(size_type)
		BOOST_MPL_HAS_XXX_TRAIT_DEF(reference)
		BOOST_MPL_HAS_XXX_TRAIT_DEF(key_type)
		BOOST_MPL_HAS_XXX_TRAIT_DEF(mapped_type)
		BOOST_MPL_HAS_XXX_TRAIT_DEF(first_type)
		BOOST_MPL_HAS_XXX_TRAIT_DEF(second_type)
	}

	template <typename T, typename Enable = void>
	struct is_container
		: boost::mpl::bool_<
			detail::has_value_type<T>::value &&
			detail::has_iterator<T>::value &&
			detail::has_size_type<T>::value &&
			detail::has_reference<T>::value
		>
	{};

	template <typename T, typename Enable = void>
	struct is_map
		: boost::mpl::bool_<
			detail::has_key_type<T>::value &&
			detail::has_mapped_type<T>::value
		>
	{};

	template <typename T, typename Enable = void>
	struct is_pair
		: boost::mpl::bool_<
			detail::has_first_type<T>::value &&
			detail::has_second_type<T>::value
		>
	{};

	template <typename T>
	struct is_container<T&>
		: is_container<T>
	{};

	template <typename T>
	struct is_map<T&>
		: is_map<T>
	{};

	template<typename T>
	struct remove_constref
	{
		typedef typename std::remove_const<typename std::remove_reference<typename std::remove_const<T>::type>::type>::type type;
	};

	//std::string
	template<typename T>
	typename std::enable_if<std::is_same<T, std::string>::value, std::string>::type
	lua_check(lua_State *L, int n)
	{
		return luaL_checkstring(L, n);
	}
	template<typename T>
	typename std::enable_if<std::is_same<T, std::string>::value, void>::type
	lua_push(lua_State *L, const T& val)
	{
		lua_pushlstring(L, val.c_str(), val.size());
	}

	//config
	template<typename T>
	typename std::enable_if<std::is_same<T, config>::value, config>::type
	lua_check(lua_State *L, int n)
	{
		return luaW_checkconfig(L, n);
	}
	template<typename T>
	typename std::enable_if<std::is_same<T, config>::value, void>::type
	lua_push(lua_State *L, const config& val)
	{
		luaW_pushconfig(L, val);
	}

	//location
	template<typename T>
	typename std::enable_if<std::is_same<T, map_location>::value, map_location>::type
	lua_check(lua_State *L, int n)
	{
		return luaW_checklocation(L, n);
	}
	template<typename T>
	typename std::enable_if<std::is_same<T, map_location>::value, void>::type
	lua_push(lua_State *L, const map_location& val)
	{
		luaW_pushlocation(L, val);
	}

	//enums generated by MAKE_ENUM
	template<typename T>
	typename std::enable_if<std::is_base_of<enum_tag, T>::value, T>::type
	lua_check(lua_State *L, int n)
	{
		T val;
		std::string str = lua_check_impl::lua_check<std::string>(L, n);
		if(!val.parse(str))
		{
			luaL_argerror(L, n, ("cannot convert " + str + " to enum " + T::name()).c_str());
		}
		return val;
	}
	template<typename T>
	typename std::enable_if<std::is_base_of<enum_tag, T>::value, void>::type
	lua_push(lua_State *L, T val)
	{
		lua_check_impl::lua_push(L, val.to_string());
	}

	//t_string
	template<typename T>
	typename std::enable_if<std::is_same<T, t_string>::value, t_string>::type
	lua_check(lua_State *L, int n)
	{
		return luaW_checktstring(L, n);
	}
	template<typename T>
	typename std::enable_if<std::is_same<T, t_string>::value, void>::type
	lua_push(lua_State *L, const t_string& val)
	{
		luaW_pushtstring(L, val);
	}

	//bool
	template<typename T>
	typename std::enable_if<std::is_same<T, bool>::value, bool>::type
	lua_check(lua_State *L, int n)
	{
		return luaW_toboolean(L, n);
	}
	template<typename T>
	typename std::enable_if<std::is_same<T, bool>::value, void>::type
	lua_push(lua_State *L, bool val)
	{
		lua_pushboolean(L, val);
	}

	//double, float
	template<typename T>
	typename std::enable_if<std::is_floating_point<T>::value, T>::type
	lua_check(lua_State *L, int n)
	{
		return luaL_checknumber(L, n);
	}
	template<typename T>
	typename std::enable_if<std::is_floating_point<T>::value, void>::type
	lua_push(lua_State *L, T val)
	{
		lua_pushnumber(L, val);
	}

	//integer types
	template<typename T>
	typename std::enable_if<std::is_integral<T>::value && !std::is_same<T, bool>::value, T>::type
	lua_check(lua_State *L, int n)
	{
		return luaL_checkinteger(L, n);
	}

	template<typename T>
	typename std::enable_if<std::is_integral<T>::value && !std::is_same<T, bool>::value, void>::type
	lua_push(lua_State *L, T val)
	{
		lua_pushnumber(L, val);
	}

	//std::pair
	//Not sure if the not_<is_const> is required; only (maybe) if std::map matches is_container
	template<typename T>
	typename std::enable_if<is_pair<T>::value && !std::is_const<typename T::first_type>::value, T>::type
	lua_check(lua_State *L, int n)
	{
		T result;
		if (lua_istable(L, n)) {
			lua_rawgeti(L, n, 1);
			result.first = lua_check<const typename T::first_type&>(L, -1);
			lua_rawgeti(L, n, 2);
			result.second = lua_check<const typename T::second_type&>(L, -1);
			lua_pop(L, 2);
		}
		return result;
	}
	template<typename T>
	typename std::enable_if<is_pair<T>::value && !std::is_const<typename T::first_type>::value, void>::type
	lua_push(lua_State *L, const T& val)
	{
		lua_newtable(L);
		lua_push<const typename T::first_type&>(L, val.first);
		lua_rawseti(L, -2, 1);
		lua_push<const typename T::second_type&>(L, val.second);
		lua_rawseti(L, -2, 2);
	}

	//std::vector and similar but not std::string
	template<typename T>
	typename std::enable_if<is_container<T>::value && !std::is_same<T, std::string>::value, T>::type
	lua_check(lua_State * L, int n)
	{
		if (lua_istable(L, n))
		{
			T res;
			for (int i = 1, i_end = lua_rawlen(L, n); i <= i_end; ++i)
			{
				lua_rawgeti(L, n, i);
				res.push_back(lua_check_impl::lua_check<typename remove_constref<typename T::reference>::type>(L, -1));
				lua_pop(L, 1);
			}
			return res;
		}
		else
		{
			luaL_argerror(L, n, "Table expected");
			throw "luaL_argerror returned"; //shouldnt happen, luaL_argerror always throws.
		}
	}

#if defined(__GNUC__) && !defined(__clang__)
#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8 )
// 'list.size()' below is unsigned for some (most but not all) list types.
#pragma GCC diagnostic ignored "-Wtype-limits"
#endif
#endif

	//also accepts things like std::vector<int>() | std::adaptors::transformed(..)
	template<typename T>
	typename std::enable_if<
		is_container<T>::value && !std::is_same<T, std::string>::value && !is_map<T>::value
		, void
	>::type
	lua_push(lua_State * L, const T& list )
	{
		// NOTE: T might be some boost::iterator_range type where size might be < 0. (unfortunately in this case size() does not return T::size_type)
		assert(list.size() >= 0);
		lua_createtable(L, list.size(), 0);
		int i = 1;
		for(typename T::const_iterator iter = list.begin(); iter != list.end(); ++iter) {
			lua_check_impl::lua_push<typename remove_constref<typename T::reference>::type>(L, *iter);
			lua_rawseti(L, -2, i++);
		}
	}


	//accepts std::map TODO: add a check function for that
	template<typename T>
	typename std::enable_if<is_map<T>::value, void>::type
	lua_push(lua_State * L, const T& map )
	{
		lua_newtable(L);
		for(const typename T::value_type& pair : map)
		{
			lua_check_impl::lua_push<typename remove_constref<typename T::key_type>::type>(L, pair.first);
			lua_check_impl::lua_push<typename remove_constref<typename T::mapped_type>::type>(L, pair.second);
			lua_settable(L, -3);
		}
	}

}

template<typename T>
typename lua_check_impl::remove_constref<T>::type lua_check(lua_State *L, int n)
{
	//remove possible const& to make life easier for the impl namespace.
	return lua_check_impl::lua_check<typename lua_check_impl::remove_constref<T>::type>(L, n);
}

template<typename T>
void lua_push(lua_State *L, const T& val)
{
	return lua_check_impl::lua_push<typename lua_check_impl::remove_constref<T>::type>(L, val);
}
